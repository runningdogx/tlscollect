#!/usr/bin/env ruby
#

require 'getoptlong'
require 'socket'

$: << File.join(File.dirname(__FILE__), "..", "lib")
require 'tlscollect'

opts = GetoptLong.new(
  [ '--host', '-H', GetoptLong::REQUIRED_ARGUMENT ],
  [ '--addr', '-a', GetoptLong::REQUIRED_ARGUMENT ],
  [ '--port', '-p', GetoptLong::REQUIRED_ARGUMENT ],
  [ '--fast', '-f', GetoptLong::NO_ARGUMENT ],
  [ '--timeout', '-t', GetoptLong::REQUIRED_ARGUMENT ],
  [ '--help', '-h', GetoptLong::NO_ARGUMENT ],
)

def usage
  puts "Usage:"
  puts "tlscollect [options...] host[:port]"
  puts "  --host <host> [servername for TLS SNI extension]"
  puts "  --starttls [for SMTP/IMAP, not implemented]"
  puts "  --fast [disables full ciphersuite probing]"
  puts "  --timeout <n> [sets ssl connection timeout to <n> seconds]"
  puts
  puts "examples:"
  puts "  tlscollect www.google.com   [scans all ips for www.google.com, port 443]"
  puts "  tlscollect --host x www.google.com [sends x as TLS Servername extension]"
  puts "  tlscollect [::1]:8443  [scans ipv6 localhost port 8443]"
  exit 0
end

def split_host_port(hostspec, default_port = 443)
  /^(?<hostmatch>.+?)(:(?<portmatch>[0-9]+))?$/ =~ hostspec
  if hostmatch and hostmatch[0] == '[' and hostmatch[-1] == ']'
    host = hostmatch[1..-2]
  else
    host = hostmatch
  end

  port = (portmatch.nil? ? default_port : portmatch.to_i)

  [host, port.to_i]
end

host = addr = nil
port = 443
fast = false
ctimeout = 10
opts.each do |opt, arg|
  case opt
    when '--help'
      usage
    when '--host'
      host = arg
    when '--addr' # deprecated
      addr = arg
    when '--port' # deprecated
      port = arg.to_i
    when '--fast'
      fast = true
    when '--timeout'
      ctimeout = arg.to_i
      ctimeout = 1 if ctimeout < 1
  end
end


if ARGV.length > 0
  # new style command line
  host, port = split_host_port(ARGV[0], port)
else
  # old style command line
  usage if not (addr || host)
  host ||= addr
end

addrs = (addr ? [addr] : TCPSocket.gethostbyname(host)[3..-1])
puts "Beginning collection for the following addresses:\n\t#{addrs.join("\n\t")}\n"
addrs.each do |addr|
  puts "\nTLS configuration for #{host} (#{addr}), port #{port}\n\n"

  collector = TLSCollect::Collector.new(:host => host, :addr => addr,
                                        :port => port, :ctimeout => ctimeout)
  collector.collect_basic

  puts "available protocols:\n\t#{collector.protocols.join("\n\t")}\n\n"
  puts "certificate:"
  puts "\tsubject: #{collector.certificate.cn}"
  # puts "\tverified: #{collector.certificate.verified ? "YES" : "NO"}"
  puts "\tvalid for host: #{collector.certificate.valid?(host) ? "YES" : "NO"}"
  puts "\tkey length: #{collector.certificate.key_length}#{collector.certificate.short? ? " (TOO SHORT)" : ""}"
  puts "\thash algorithm: #{collector.certificate.hash_algorithm}"
  puts "\tencryption algorithm: #{collector.certificate.encryption_algorithm}"
  puts "\tissued: #{collector.certificate.raw.not_before}"
  puts "\texpires: #{collector.certificate.raw.not_after}#{(collector.certificate.expired? ? " (EXPIRED)" : "")}#{collector.certificate.longevity? ? "" : " (TOO LONG)"}\n\n"
  puts "default cipher:\n\t#{collector.default_cipher.cipher}\n\n"

  if not fast
    collector.collect_cipher_order
    puts "available ciphers:\n\t#{collector.ciphers.map{|cipher| cipher.cipher}.join("\n\t")}\n\n"
  end
end
